import pandas as pd
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import PowerTransformer
import numpy as np

# Define KPI columns for each model
model_kpi_mapping = {
    'RandomForestRegressor': [
        'NULOs that Remain High Priority',
        'Billing exceeds Authorization (Abnormal Unfilled Customer Orders)'
    ],
    'GradientBoostingRegressor': [
        'RBC Level- Total Negative Authorizations',
        'Negative Liquidations - Travel (DTC: CS, CT, TO)'
    ],
    'DecisionTreeRegressor': [
        'RBC Level- Total Negative Billed',
        'Cost Transfer Allocation - "COE"'
    ],
    'LinearRegression': [
        'Permanent Journal Vouchers',
        'Invalid LOA'
    ]
}

# Load data
def load_data(sheet_name, bso_name):
    print(f"Loading data for sheet: {sheet_name}, BSO: {bso_name}")
    data = pd.read_excel("/Volumes/navy-fip4-ya-dev/data_cleansing_dev/visualization_dev/All BSOs Dashboards.xlsx", sheet_name=sheet_name)
    data['BSO'] = bso_name  # Add the BSO column
    data['Date'] = pd.to_datetime(data['Date'])  # Convert Date column to datetime
    return data

# Generate predictions
def generate_predictions(data, kpi_columns, model):
    predictions = []
    data['DateNumeric'] = data['Date'].map(pd.Timestamp.toordinal)  # Convert Date to numeric

    for kpi_column in kpi_columns:
        if kpi_column not in data.columns:
            print(f"KPI column {kpi_column} not found. Skipping...")
            continue

        X = data[['DateNumeric']]
        y = data[kpi_column].values

        if len(X) == 0 or len(y) == 0:
            print(f"No data available for KPI column {kpi_column}. Skipping...")
            continue

        # Apply transformation
        transformer = PowerTransformer()
        try:
            y_transformed = transformer.fit_transform(y.reshape(-1, 1)).flatten()
        except Exception as e:
            print(f"Error transforming KPI {kpi_column}: {e}. Skipping...")
            continue

        # Train-test split
        X_train, X_test, y_train, y_test = train_test_split(X, y_transformed, test_size=0.2, random_state=42)

        if len(X_train) == 0 or len(y_train) == 0:
            print(f"Empty training data for KPI column {kpi_column}. Skipping...")
            continue

        # Fit the model
        try:
            model.fit(X_train, y_train)
            print(f"Model trained successfully for KPI: {kpi_column}")
        except Exception as e:
            print(f"Error training model for KPI {kpi_column}: {e}. Skipping...")
            continue

        # Generate future dates
        last_date = data['Date'].max()
        future_dates = [last_date + pd.Timedelta(weeks=i) for i in range(1, 4)]
        future_numeric = pd.DataFrame({'DateNumeric': [d.toordinal() for d in future_dates]})

        # Make predictions
        try:
            future_preds = model.predict(future_numeric)
            future_preds_original = transformer.inverse_transform(future_preds.reshape(-1, 1)).flatten()

            for date, pred in zip(future_dates, future_preds_original):
                predictions.append({'Date': date, 'KPI': kpi_column, 'Prediction': pred, 'BSO': data['BSO'].iloc[0]})

        except Exception as e:
            print(f"Error making predictions for KPI {kpi_column}: {e}")

    return predictions

# Run model predictions
def run_model_predictions(sheet_name, bso_name, model_name, kpi_columns):
    print(f"Running predictions for model: {model_name}, sheet: {sheet_name}, BSO: {bso_name}")
    data = load_data(sheet_name, bso_name)
    model_map = {
        'RandomForestRegressor': RandomForestRegressor(random_state=42),
        'GradientBoostingRegressor': GradientBoostingRegressor(random_state=42),
        'DecisionTreeRegressor': DecisionTreeRegressor(random_state=42),
        'LinearRegression': LinearRegression()
    }
    model = model_map.get(model_name)
    if not model:
        print(f"Model {model_name} not found.")
        return pd.DataFrame()

    return pd.DataFrame(generate_predictions(data, kpi_columns, model))

# Process each BSO and model
ffc_data_random_forest = run_model_predictions("FFC Proj", "USFFC", "RandomForestRegressor", model_kpi_mapping["RandomForestRegressor"])
ffc_data_gradient_boosting = run_model_predictions("FFC Proj", "USFFC", "GradientBoostingRegressor", model_kpi_mapping["GradientBoostingRegressor"])
ffc_data_decision_tree = run_model_predictions("FFC Proj", "USFFC", "DecisionTreeRegressor", model_kpi_mapping["DecisionTreeRegressor"])
ffc_data_linear_regression = run_model_predictions("FFC Proj", "USFFC", "LinearRegression", model_kpi_mapping["LinearRegression"])

# Combine results for all models
all_predictions = pd.concat([ffc_data_random_forest, ffc_data_gradient_boosting, ffc_data_decision_tree, ffc_data_linear_regression], ignore_index=True)

# Show the final DataFrame
print(all_predictions)
