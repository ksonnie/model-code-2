import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler
import numpy as np

# File path and relevant sheet name
file_path = "/Volumes/navy-fip4-ya-dev/data_cleansing_dev/visualization_dev/All BSOs Dashboards.xlsx"
sheet_name = "RESFOR Proj"

# List of KPI columns to process
kpi_columns = [
    "Permanent Journal Vouchers",
    "OTA w/ Closed RON",
    "OTA w/ Excluded Purchase Order (PO)",
    "Non-Labor Duplicates on SDN/ACRN/CLIN/SLIN",
    "Invalid LOA"
]

# Load the Excel data
def load_data(file_path, sheet_name):
    data = pd.read_excel(file_path, sheet_name=sheet_name)
    data['Date'] = pd.to_datetime(data['Date'], errors='coerce')
    data.dropna(subset=['Date'], inplace=True)  # Drop rows with invalid dates
    return data

# Function to process all KPI columns and add predictions for each date
def process_kpi_columns(data, kpi_columns):
    scaler = MinMaxScaler()
    last_date = data['Date'].max()  # Get the latest date in the data

    # Prepare a DataFrame to hold the combined original and predicted data
    final_data = data.copy()

    for kpi_column in kpi_columns:
        if kpi_column in data.columns:
            print(f"Processing KPI: {kpi_column}")

            # Prepare historical data for the current KPI
            kpi_data = data[['Date', kpi_column]].copy()
            kpi_data.dropna(subset=[kpi_column], inplace=True)  # Remove rows where KPI is NaN

            # Skip processing if insufficient data
            if len(kpi_data) < 2:
                print(f"Skipping {kpi_column}: insufficient data.")
                continue

            # Convert Date to numeric for modeling
            kpi_data['DateNumeric'] = kpi_data['Date'].map(pd.Timestamp.toordinal)
            X = kpi_data[['DateNumeric']]
            y = kpi_data[kpi_column]

            # Scale the numeric data
            X_scaled = scaler.fit_transform(X)

            # Initialize and train the Linear Regression model
            model = LinearRegression()
            model.fit(X_scaled, y)

            # Generate predictions for the next 3 weeks
            current_last_date = last_date

            for i in range(3):
                # Increment the date for the prediction
                next_date = current_last_date + pd.Timedelta(days=7)

                # Prepare input for prediction
                next_date_numeric = scaler.transform([[next_date.toordinal()]])[0][0]
                next_prediction = model.predict([[next_date_numeric]])[0]

                # Append the prediction to the historical data
                new_row = {
                    'Date': next_date,
                    kpi_column: next_prediction,
                    'DateNumeric': next_date.toordinal()
                }
                kpi_data = pd.concat([kpi_data, pd.DataFrame([new_row])], ignore_index=True)

                # Retrain the model with updated data
                X = kpi_data[['DateNumeric']]
                y = kpi_data[kpi_column]
                X_scaled = scaler.fit_transform(X)
                model.fit(X_scaled, y)

                # Append the prediction to the final data
                final_data = pd.concat([final_data, pd.DataFrame([{'Date': next_date, kpi_column: next_prediction}])], ignore_index=True)

                # Update the current last date
                current_last_date = next_date

    # Ensure the Date column is formatted correctly
    final_data['Date'] = pd.to_datetime(final_data['Date']).dt.strftime('%m/%d/%Y')
    return final_data

# Main execution
data = load_data(file_path, sheet_name)
final_data = process_kpi_columns(data, kpi_columns)

# Display the final result
columns_to_keep = ["Date"] + kpi_columns
final_data_filtered = final_data[columns_to_keep]

display(final_data_filtered)
